#!/usr/bin/env bash


usage() {
    local b; b="$(printf '\e[1m')"
    local u; u="$(printf '\e[4m')"
    local r; r="$(printf '\e[0m')"

    cat <<EOF

${b}NAME${r}
       ${u}git-context-graph${r} - Show graph log of branch, its remote counterparts and default branch.

${b}SYNOPSIS${r}
       ${u}git${r} ${u}context-graph${r} [--no-default] [-a|--add] [<branch>...]
       ${u}git${r} ${u}context-graph${r} [<git-log options>...] [<options>...] [<branch>...] [-- <paths>...]
       ${u}git${r} ${u}context-graph${r} (-l|--list) [-s|--short] [<branch>...]
       ${u}git${r} ${u}context-graph${r} (-h|--usage)

${b}DESCRIPTION${r}
       This command is a shortcut to:

           git log --color --graph --abbrev-commit --decorate --pretty=oneline \\
               <branch> origin/<branch> other-remote/<branch> ... \\
               [main    origin/main     other-remote/main] ...


       ${u}git${r} ${u}context-graph${r} [--no-default] [-a|--add] [<branch>...]
           Show graph log of branch, its remote counterparts and default branch.

       ${u}git${r} ${u}context-graph${r} [<git-log options>...] [<options>...] [<branch>...] [-- <paths>...]
           git-log options can be used to refine or customize the output
           (see git-log documentation: https://git-scm.com/docs/git-log)
           Ex:
             git context-graph --pretty=medium -- some/path

       ${u}git${r} ${u}context-graph${r} (-l|--list) [-s|--short] [<branch>...]
           List branches that would be shown in the graph (does not display graph).

       ${u}git${r} ${u}context-graph${r} (-h|--usage)
           Show this help.

${b}ARGUMENTS${r}
       <branch>...
           Branches to show graph for. If omitted, current branch will be used.

${b}OPTIONS${r}
       -a|--add
           Consider <branch> arguments as additional branches (added to current branch).

       --no-default
           Show only related branches (local and remote), without default branch ('main' / 'master').

       -l|--list
           List branches that would be shown in the graph (does not display graph).

       -s|--short
           Use short branch names when listing branches (without 'refs/heads/' or 'refs/remotes/').
           Implies --list.

       -h|--usage
           Show this help.

EOF
}

git_current_branch() {
    # `git branch --show-current` is available starting from Git 2.22
    # fallback to `git rev-parse --abbrev-ref HEAD` if first command fails
    (git branch --show-current 2>/dev/null) ||
        git rev-parse --abbrev-ref HEAD
}

branch_with_remotes() {
    local branch=${1:-$(git_current_branch)}

    # Convert 'refs/heads/my-branch' to 'my-branch'
    local short_branch=${branch#"refs/heads/"}

    if [[ $short_branch == "HEAD" ]]; then
        echo "$branch"
        return
    fi

    # Branches with same name on all remotes
    local same_name_refs;
    same_name_refs=$(git for-each-ref --format="%(refname)" "refs/**/$short_branch")
    echo "$same_name_refs"

    # Remote tracking branch (in case name is different)
    local tracking_remote;
    tracking_remote=$(git for-each-ref --format='%(upstream)' "$(git rev-parse --symbolic-full-name "$branch" 2> /dev/null)")
    [[ ! $same_name_refs =~ $tracking_remote ]] && echo "$tracking_remote"
}

related_branches() {
    local branches=("$@")

    local current_branch;
    current_branch=$(git_current_branch)
    [[ -z $current_branch ]] && current_branch="HEAD"

    # Default to current branch
    [[ ${#branches[@]} -eq 0 ]] && branches[0]="$current_branch"

    # Add current branch to list when considering arguments are additional branches
    [[ -n $GIT_CG_ADD_TO_CURRENT ]] && branches+=("$current_branch")

    local branch
    local related_branches
    for branch in "${branches[@]}"; do
        related_branches="${related_branches}\n$(branch_with_remotes "$branch")"
    done

    # de-duplicate and remove blank lines
    echo -e "${related_branches}" | sort -u | grep "\S"
}

default_branches() {
    local default_branches

    # default remote branches
    local remote
    for remote in $(git remote); do
        local remote_default
        remote_default=$(git symbolic-ref "refs/remotes/${remote}/HEAD" -- 2>/dev/null)
        if [[ -n $remote_default ]]; then
            local short_default=${remote_default#"refs/remotes/${remote}/"}
            default_branches="${default_branches}\n${short_default}"
        fi
    done

    # standard default branches
    if [[ -z $default_branches ]]; then
        local std_default
        for std_default in 'main' 'master'; do
            git show-ref --verify --quiet "refs/heads/$std_default" &&
                default_branches="${default_branches}\n${std_default}"
        done
    fi

    # de-duplicate and remove blank lines
    echo -e "${default_branches}" | sort -u | grep "\S"
}

context_branches() {
    local context_branches
    context_branches="$(related_branches "$@")"

    if [[ -z $GIT_CG_SHOW_RELATED_ONLY ]]; then
        local default_branch
        for default_branch in $(default_branches); do
            context_branches="${context_branches}\n$(branch_with_remotes "$default_branch")"
        done
    fi

    # de-duplicate and remove blank lines
    context_branches=$(echo -e "${context_branches}" | sort -u | grep "\S")

    # short branch listing
    [[ -n $GIT_CG_LIST_SHORT ]] && context_branches=$(echo "$context_branches" |
        sed -e "s/^refs\/heads\///" |
        sed -e "s/^refs\/remotes\///")

    echo "$context_branches"
}


# Check current directory is a Git repository
if ! git rev-parse 2> /dev/null; then
    echo "Not a git repository"
    exit 1
fi


# Parse options & arguments
GIT_CG_BRANCHES=()
GIT_LOG_OPTIONS=()
GIT_LOG_PATHS=()
while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--add) GIT_CG_ADD_TO_CURRENT=1; shift ;;

        --no-default) GIT_CG_SHOW_RELATED_ONLY=1; shift ;;

        -l|--list)  GIT_CG_LIST=1;                      shift ;;
        -s|--short) GIT_CG_LIST=1; GIT_CG_LIST_SHORT=1; shift ;;

        -h|--usage) GIT_CONTEXT_GRAPH_HELP=1; shift ;;

        --) GIT_LOG_PATHS+=("$1");   shift ;;
        -*) GIT_LOG_OPTIONS+=("$1"); shift ;;
        *)
            [[ ${#GIT_LOG_PATHS[@]} -eq 0 ]] &&
                GIT_CG_BRANCHES+=("$1") ||
                GIT_LOG_PATHS+=("$1")
            shift ;;
    esac
done


# Alternative outputs
if [[ -n $GIT_CG_LIST ]]; then
    context_branches "${GIT_CG_BRANCHES[@]}"
    exit 0
fi
if [[ -n $GIT_CONTEXT_GRAPH_HELP ]]; then
    usage
    exit 0
fi


# Show graph
# shellcheck disable=SC2046 # use word splitting for GIT_CG_BRANCHES
git log --color --graph --abbrev-commit --decorate --pretty=oneline \
    "${GIT_LOG_OPTIONS[@]}" \
    $(context_branches "${GIT_CG_BRANCHES[@]}") \
    "${GIT_LOG_PATHS[@]}"
